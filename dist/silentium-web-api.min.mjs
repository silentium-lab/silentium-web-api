import{sourceOf as e,value as t,patronOnce as n,destroy as r,give as o,sourceAll as s,guestCast as i,patron as c,subSourceMany as a}from"silentium";const l=(s,i)=>{const c=e(),a=e=>{const{state:t}=e;t?.url&&o(String(t.url),c)};return t(s,n((e=>{e.addEventListener("popstate",a)}))),t(i,n((()=>{r([c]),t(s,(e=>{e.removeEventListener("popstate",a)}))}))),c},u=(e,n)=>r=>{t(s([n,e]),i(r,(([e,t])=>{t.pushState({url:e,date:Date.now()},"",e),o(e,r)})))},d=(n,r,i)=>{const a=e();return t(s([r,n]),c((([e,t])=>{t.fetch(e).then((e=>{let t;return t="application/json"===e.headers.get("Content-Type")?e.json():e.text(),e.ok?t:Promise.reject(t)})).then((e=>{o(e,a)})).catch((e=>{o(e,i)}))}))),a},p=(e,n,r)=>c=>{t(s([r,n]),i(c,(([t,n])=>{const r=n.querySelector(t);if(r)o(r,c);else{if(!e)throw new Error(`Element with selector=${t} was not found!`);{const r=n.body,s={childList:!0,subtree:!0},i=e.get((e=>{for(const r of e)if("childList"===r.type){const e=n.querySelector(t);if(e){o(e,c),i.disconnect();break}}}));i.observe(r,s)}}})))},h=(n,r,i="")=>{const l=e();return a(l,[n,r,i]),t(s([n,r,i]),c((([e,t,n])=>{o(e.getAttribute(t)||n,l)}))),l},v=(e,n)=>r=>{t(s([e,n]),i(r,(([e,t])=>{const n=e.createElement("style");n.textContent=t,e.head.appendChild(n),o(t,r)})))},L=(e,n)=>{const r=()=>{t(n,(t=>{e.give(t.value)}))};let o=null;return t(n,c((e=>{o&&(e.removeEventListener("keyup",r),e.removeEventListener("change",r)),e.addEventListener("keyup",r),e.addEventListener("change",r),o=e}))),t(s([e,n]),c((([e,t])=>{t.value=String(e)}))),e},f=(e,n)=>(t(s([e,n]),c((([e,t])=>{t.textContent=e}))),e),g=(e,n)=>(t(s([n,e]),c((([e,t])=>{t.innerHTML=e}))),n),m=(e,n,r)=>{const o=s([r,n,e]);return t(o,c((([e,t,n])=>{n.log("LOG:",t,e)}))),r};export{h as attribute,p as element,d as fetched,u as historyNewPate,l as historyPoppedPage,g as html,L as input,m as log,v as styleInstalled,f as text};
//# sourceMappingURL=silentium-web-api.min.mjs.map
